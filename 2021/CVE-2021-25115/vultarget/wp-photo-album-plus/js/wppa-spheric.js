// wppa-spheric.js
//
// contains wppa functions for simple zoomable photos
//
var wppaJsSphericVersion = '8.0.00.017';

// The main proccedure
function wppaDoSphericPan(mocc, xdata) {

	var $ 		= jQuery;
	if ( xdata ) wppaSphericData[mocc] = xdata;
	var data 	= update(mocc, data);

	// Been here before with same parms?
	if ( data.initialized ) return;
	if ( data.abort ) return;

	// If in lightbox but lightbox not open, quitImage
	if ( data.isLightbox && ! wppaOvlOpen ) {
		return;
	}

	// Are we in the viewport and not lightbox?
	if ( ! data.isLightbox && ! wppaIsElementInViewport( $("#wppa-pan-div-"+mocc) ) ) {

		setTimeout( function() {wppaDoSphericPan(mocc)}, 1000 );
		update(mocc,{vtime:timnow()});
		return;
	}

	// Clear previous instance
	if ( data.wppaRenderer ) {
		data.wppaRenderer.state.reset();
		data.wppaSphere.dispose();
		data.wppaSphereMaterial.dispose();
		data.texture.dispose();
	}

	// If lightbox, show spinner
	if ( data.isLightbox && wppaOvlOpen ) {
		$("#wppa-ovl-spin").show();

		// Clear normal image
		$("#wppa-overlay-ic").html("");
	}

	// Find additional data
	data.manCtrl 	= false;
	data.butDown 	= false;
	data.lon 		= 180;
	data.lat 		= 0;
	data.dFov 		= 0;
	data.abort 		= false;
	data.aspect 	= 2;
	data.div 		= $("#wppa-pan-div-"+mocc );
	data.left 		= $("#wppa-pctl-left-"+mocc );
	data.right 		= $("#wppa-pctl-right-"+mocc );
	data.up 		= $("#wppa-pctl-up-"+mocc );
	data.down 		= $("#wppa-pctl-down-"+mocc );
	data.zoomin 	= $("#wppa-pctl-zoomin-"+mocc );
	data.zoomout 	= $("#wppa-pctl-zoomout-"+mocc );
	data.prev 		= $("#wppa-pctl-prev-"+mocc );
	data.next 		= $("#wppa-pctl-next-"+mocc );
	data.pause 		= false;
	data.mFakt 		= ( wppaIsMobile ? '2' : '1' );
	data.time 		= 0;

	if ( data.isLightbox ) {
		wppaGlobalOvlPanoramaId++;
		data.uId = wppaGlobalOvlPanoramaId;
	}

	$(data.div).html("");

	if ( ! data.wppaRenderer ) data.wppaRenderer = new THREE.WebGLRenderer();
	data.wppaRenderer.setSize(data.width, data.height);
	$(data.div).append(data.wppaRenderer.domElement);

	data.wppaScene = new THREE.Scene();

	data.wppaSphere = new THREE.SphereGeometry(100, 100, 40);
	data.wppaSphere.applyMatrix4(new THREE.Matrix4().makeScale(-1, 1, 1));

	data.texture = new THREE.TextureLoader().load(data.url);
	data.wppaSphereMaterial = new THREE.MeshBasicMaterial({map:data.texture});

	data.wppaSphereMesh = new THREE.Mesh(data.wppaSphere, data.wppaSphereMaterial);
	data.wppaScene.add(data.wppaSphereMesh);

		data.right.on("touchstart", function(e){rDown(mocc,e)});
		data.right.on("touchend", function(e){bUp(mocc,e)});
		data.left.on("touchstart", function(e){lDown(mocc,e)});
		data.left.on("touchend", function(e){bUp(mocc,e)});
		data.up.on("touchstart", function(e){uDown(mocc,e)});
		data.up.on("touchend", function(e){bUp(mocc,e)});
		data.down.on("touchstart", function(e){dDown(mocc,e)});
		data.down.on("touchend", function(e){bUp(mocc,e)});
		data.zoomin.on("touchstart", function(e){zInDown(mocc,e)});
		data.zoomin.on("touchend", function(e){bUp(mocc,e)});
		data.zoomout.on("touchstart", function(e){zOutDown(mocc,e)});
		data.zoomout.on("touchend", function(e){bUp(mocc,e)});

		if ( data.enableManual && $("#wppa-pan-div-"+mocc+" canvas").length > 0 ) {

			$("#wppa-pan-div-"+mocc+" canvas")[0].addEventListener("touchstart", function(e){onMs(mocc,e)});
			$("#wppa-pan-div-"+mocc+" canvas")[0].addEventListener("touchmove", function(e){onMm(mocc,e)});
			$("#wppa-pan-div-"+mocc+" canvas")[0].addEventListener("touchend", function(e){onMe(mocc,e)});
		}

		data.right.on("mousedown", function(e){rDown(mocc,e)});
		data.right.on("mouseup", function(e){bUp(mocc,e)});
		data.left.on("mousedown", function(e){lDown(mocc,e)});
		data.left.on("mouseup", function(e){bUp(mocc,e)});
		data.up.on("mousedown", function(e){uDown(mocc,e)});
		data.up.on("mouseup", function(e){bUp(mocc,e)});
		data.down.on("mousedown", function(e){dDown(mocc,e)});
		data.down.on("mouseup", function(e){bUp(mocc,e)});
		data.zoomin.off("mousedown");
		data.zoomin.on("mousedown", function(e){zInDown(mocc,e)});
		data.zoomin.off("mouseup");
		data.zoomin.on("mouseup", function(e){bUp(mocc,e)});
		data.zoomout.on("mousedown", function(e){zOutDown(mocc,e)});
		data.zoomout.on("mouseup", function(e){bUp(mocc,e)});

		if ( data.enableManual && $("#wppa-pan-div-"+mocc+" canvas").length > 0 ) {

			$("#wppa-pan-div-"+mocc+" canvas").on("mousedown", function(e){onMs(mocc,e)});
			$("#wppa-pan-div-"+mocc+" canvas").on("mousemove", function(e){onMm(mocc,e)});
			$("#wppa-pan-div-"+mocc+" canvas").on("mouseup", function(e){onMe(mocc,e)});
			$("#wppa-pan-div-"+mocc+" canvas")[0].addEventListener("wheel", function(e){onDivWheel(mocc,e)});
		}


	if ( data.isLightbox ) {
		$("body").on("quitimage", function(e){quitImage(mocc,e)});
		$("#wppa-pctl-div-"+mocc).on("click", function(e){wppaKillEvent(e)});
	}

	update(mocc,data);

	// Install Resize handler
//	if ( data.isLightbox ) {
//		$(window).off("wpparesizeend",wppaOvlShowSame);
//		$(window).on("wpparesizeend",wppaOvlShowSame);
//	}
//	else {
		$(window).on("wpparesizeend",function(e){resize(mocc,e)});
//	}

	// Optionally disable rightclick
	wppaProtect();

	// Redo when visible again due to tabby change tab
	$(document).on("tabbychange",function(e){tabbyChange(mocc,e)});

	resize(mocc);
	data.intervalTimer = setInterval(function(){resize(mocc)},1000);
//	setTimeout(function(){resize(mocc)},1000);
//	setTimeout(function(){resize(mocc)},2000);
//	resize(mocc);

	function render(mocc){

//	wppaConsoleLog("spheric render called","force");
		var data = update(mocc);
		var inViewport = wppaIsElementInViewport($("#wppa-pan-div-"+mocc+" canvas"));

		// To prevent multiple invocations - caused by e.g. resize events - see if we were here less than the repeat time ago
		if ( ! data.manCtrl && timnow() < data.time + 25 ) {
			return;
		}

		// Do not render when not in viewport, try again later
		if ( ! inViewport ) {

			// Prevent dups
			if ( timnow() < data.vtime + 1000 ) {
//				wppaConsoleLog('Skip dup spheric vtime retry mooc = ' + mocc);
				return;
			}

			// Try later
			setTimeout(function(){render(mocc)}, 1000);
			update(mocc,{vtime:timnow()});
//			wppaConsoleLog('(setTimeout) try render later (1000) mocc='+mocc+' data.manCtrl='+data.manCtrl+' deltatime = '+(timnow()-data.vtime));
			return;
		}

		update(mocc,{time:timnow()});

		if ( data.isLightbox ) {
			if ( ! wppaOvlOpen || wppaOvlActivePanorama != data.id || wppaGlobalOvlPanoramaId > data.uId ) abort=true;
		}

		if ( data.abort ) return;
		if ( ( data.butDown || data.manCtrl ) && data.autorun ) {
			data.autorun = false;
			data.dX = 0;
		}
		if ( data.dX == 0 && data.dY == 0 && data.dFov == 0 ) data.pause = true;
		if ( data.butDown ) data.pause = false;

		data.fov += data.dFov;
		data.fov = Math.max(20, Math.min(120, data.fov));
		data.wppaCamera = new THREE.PerspectiveCamera(data.fov, data.aspect, 1, 1000);
		data.wppaCamera.target = new THREE.Vector3(0, 0, 0);
		data.lon += data.dX;
		data.lat += data.dY;
		data.lat = Math.max(-85, Math.min(85, data.lat));
		data.wppaCamera.target.x = 500 * Math.sin(THREE.Math.degToRad(90 - data.lat)) * Math.cos(THREE.Math.degToRad(data.lon));
		data.wppaCamera.target.y = 500 * Math.cos(THREE.Math.degToRad(90 - data.lat));
		data.wppaCamera.target.z = 500 * Math.sin(THREE.Math.degToRad(90 - data.lat)) * Math.sin(THREE.Math.degToRad(data.lon));
		data.wppaCamera.lookAt(data.wppaCamera.target);
		if ( data.wppaRenderer ) {
			data.wppaRenderer.render(data.wppaScene, data.wppaCamera);
		}

		wppaAdjustControlbar();
		$("#wppa-ovl-spin").hide();

		var t = 25;
		if ( data.manCtrl ) t = 5;

		if ( data.autorun || ( ! data.pause && ( data.manCtrl || data.butDown ) ) ) {
			if ( data.wppaRenderer ) {
				data.timer = setTimeout(function(){render(mocc)},25);
			}
		}
		update(mocc,data);
	}

	function resize(mocc,e) {

//		wppaConsoleLog("Resize spheric mocc "+mocc+" called by "+resize.caller,"force");
		var modeIsNormal = ! wppaIsFs();

		var newWidth;
		var newHeight;


		data = update(mocc);
		if ( ! data ) return;

		if ( data.isLightbox ) {

			if ( ! wppaOvlOpen ) return;

			$("#wppa-overlay-pc").show();
			$("#wppa-overlay-pc").css("width", "");

			var widthIsLim, modeIsNormal = ! wppaIsFs();

			var contWidth,	contHeight;

			if ( modeIsNormal ) {
				contWidth = window.innerWidth ? window.innerWidth : screen.width;
				contHeight = window.innerHeight ? window.innerHeight : screen.height;
			}
			else {
				contWidth = screen.width;
				contHeight = screen.height;
			}

			// Initialize new display sizes
			var
				topMarg,
				leftMarg,
				extraX = 8,
				extraY = 8 + ( data.controls ? data.icsize + 10 : 0 ) + 30;

			// Add borderwidth in case of mode == normal
			if ( modeIsNormal ) {
				extraX += 2 * data.borderWidth;
				extraY += 2 * data.borderWidth;
			}

			// Find out if the width is the limitng dimension
			widthIsLim = ( contHeight > ( ( ( contWidth  - extraX ) / 2 ) + extraY ) );

			// Compute new sizes and margins
			if ( modeIsNormal ) {
				if ( widthIsLim ) {
					newWidth = contWidth - extraX;
					newHeight = newWidth / 2;
					topMarg = ( contHeight - newHeight - extraY ) / 2 + 20;
				}
				else {
					newHeight = contHeight - extraY;
					newWidth = newHeight * 2;
					topMarg = 20;
				}
			}
			else {
				newWidth = screen.width;
				newHeight = screen.height;
				topMarg = 0;
			}
			data.aspect = newWidth / newHeight;

			// Set css common for all 4 situations
			$("#wppa-ovl-sphericpan-container").css({top:topMarg});
			$("#wppa-overlay-pc").css({top:0});

			// Now set css for all 4 situations: Mode is normal
			if ( modeIsNormal ) {

				// Common for mode normal
				$("#wppa-ovl-sphericpan-container").css({
					backgroundColor:data.backgroundColor,
					padding:data.padding+"px",
					borderRadius:data.borderRadius+"px",
					width:newWidth
				});

				// Limit specific
				if ( widthIsLim ) {
					$("#wppa-overlay-pc").css({left:4});
				}
				else {
					$("#wppa-overlay-pc").css({left:(contWidth-newWidth)/2});
				}
			}

			// Mode is fullscreen
			else {

				// Common for mode fullscreen
				$("#wppa-ovl-sphericpan-container").css({
					backgroundColor:"transparent",
					padding:0,
					borderRadius:"0px",
					width:newWidth,
					left:(contWidth-newWidth)/2
				});

			}

			data.wppaRenderer.setSize(newWidth, newHeight);
		}

		// Not lightbox
		else {

			var containerwidth = $(data.div).parent().width();
			newWidth = containerwidth;
			newHeight = parseInt( newWidth / 2 ); // * data.height / data.width;
			if ( ! data.wppaRenderer ) return; // vanished ( by pla )
			data.wppaRenderer.setSize(newWidth, newHeight);
		}

		data.width = newWidth;
		data.height = newHeight;
		update(mocc,data);

		data.timer = setTimeout(function(){render(mocc)},250);
//		wppaConsoleLog('(setTimeout) render after resize (250)');
	}

	// Start event handlers
	// Previous / next on lightbox
	/*
	function panPrev(e) {
		$("#wppa-overlay-pc").css({display:"none"});
		$("#wppa-ovl-spin").show();
		update(mocc,{abort:true});
		$("body").trigger("quitimage");
		wppaOvlShowPrev();
	}
	function panNext(e) {
		$("#wppa-overlay-pc").css({display:"none"});
		$("#wppa-ovl-spin").show();
		update(mocc,{abort:true});
		$("body").trigger("quitimage");
		wppaOvlShowNext();
	}
	*/

	// Mouse wheel
	function onDivWheel(mocc,e) {
		e.preventDefault();
		e.stopPropagation();
		data = update(mocc);
		update(mocc, {
			manCtrl :false,
			butDown :false,
			autorun :false,
			dX 		:0,
			dFov 	:-e.deltaY * data.zoomsensitivity / ( wppaIsChrome ? 60 : 6 )
		});
		render(mocc);
		setTimeout(function(){update(mocc,{dFov:0})}, 25);
//		wppaConsoleLog('(setTimeout) after wheel');
	}

	// Manual movement on the canvas: (s(tart), m(ove), e(nd))
	function onMs(mocc,e) {
		e.preventDefault();
		e.stopPropagation();
		data = update(mocc,{
			manCtrl :true,
			butDown :false,
			autorun :false,
			dX 		:0
		});
		if ( e.touches ) {
			update(mocc,{
				sX 	:e.touches[0].clientX,
				sY 	:e.touches[0].clientY
			});
		}
		else {
			update(mocc,{
				sX 	:e.clientX,
				sY 	:e.clientY
			});
		}
		update(mocc, {
			sLon 	:data.lon,
			sLat 	:data.lat
		});
		render(mocc);
	}
	function onMm(mocc,e) {
		e.preventDefault();
		e.stopPropagation();
		data = update(mocc);
		if ( data.manCtrl ) {
			if ( e.touches ) {
				update(mocc,{
					lon 	:(data.sX - e.touches[0].clientX) * 0.1 + data.sLon,
					lat 	:(e.touches[0].clientY - data.sY) * 0.1 + data.sLat,
					pause 	:false
				});
			}
			else {
				update(mocc,{
					lon 	:(data.sX - e.clientX) * 0.1 + data.sLon,
					lat 	:(e.clientY - data.sY) * 0.1 + data.sLat,
					pause 	:false
				});
			}
			render(mocc);
		}
	}
	function onMe(mocc,e) {
		update(mocc,{manCtrl:false});
	}

	// Movement by buttons
	function zInDown(mocc,e) {
		data = update(mocc);
		update(mocc,{
			dFov 	:-0.4*data.mFakt,
			butDown :true
		});
		render(mocc);
	}
	function zOutDown(mocc,e) {
		data = update(mocc);
		update(mocc,{
			dFov 	:0.4*data.mFakt,
			butDown :true
		});
		render(mocc);
	}
	function rDown(mocc,e) {
		data = update(mocc);
		update(mocc,{
			dX 		:0.2*data.mFakt,
			butDown :true
		});
		render(mocc);
	}
	function lDown(mocc,e) {
		data = update(mocc);
		update(mocc,{
			dX 		:-0.2*data.mFakt,
			butDown :true
		});
		render(mocc);
	}
	function uDown(mocc,e) {
		data = update(mocc);
		update(mocc,{
			dY 		:0.2*data.mFakt,
			butDown :true
		});
		render(mocc);
	}
	function dDown(mocc,e) {
		data = update(mocc);
		update(mocc,{
			dY 		:-0.2*data.mFakt,
			butDown :true
		});
		render(mocc);
	}
	function bUp(mocc,e) {
		data = update(mocc);
		update(mocc,{
			dX 		:0,
			dY 		:0,
			dFov 	:0,
			butDown :false
		});
	}

	// Update data
	function update(mocc, data) {

		if ( ! wppaSphericData[mocc] ) return false;

		if (data) {
			for (var property in data) {
				wppaSphericData[mocc][property] = data[property];
			}
		}

		return wppaSphericData[mocc];
	}

	// Re-initialize this
	function tabbyChange(mocc,e) {

		data.wppaRenderer.state.reset();
		data = update(mocc,{
			initialized:false,
			abort:true,
		});

		setTimeout(function(){
			update(mocc,{abort:false});
			wppaDoSphericPan(mocc);
		},200);
//		wppaConsoleLog('(setTimeout) redo spheric after tabbychange mocc='+mocc);
	}

	// Clean up
	function quitImage(mocc,e) {

		data = update(mocc,{
			abort:true,
			autorun:false
		});
		clearTimeout(data.timer);
		clearInterval(data.intervalTimer);
		$("#wppa-pan-div-"+mocc+" canvas").hide();
		$("#wppa-pctl-div-"+mocc).hide();
		$("#wppa-overlay-pc").hide();
	}

	// Get current time in ms
	function timnow() {
		d = new Date();
		return d.getTime();
	}

}
